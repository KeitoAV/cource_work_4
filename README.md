# **Course Project 4.**

## Описание проекта

- **Аутентификация**
    
    Для того чтобы у каждого пользователя была возможность добавлять понравившиеся фильмы в закладки для просмотра позже, нам нужно их как-то разграничивать, поэтому мы организуем страницы с регистрацией и аутентификацией на основе уже изученной спецификации JWT.
    
- **Пользователи**
    
    У каждого пользователя будет страница с его профилем, где он сможет выбрать любимый жанр, указать имя и фамилию, а также в случае необходимости сменить пароль.
    
    Еще для пользователя нужно реализовать механизм добавления и удаления фильмов в/из закладок, а также просмотр всех сохраненных в закладки фильмов.
    
- **Фильмы, режиссеры, жанры**
    
    Конечно же, нужно добавить самые главные сущности — фильмы, режиссеры и жанры. Для них сделаем лишь возможность чтения (get-запросы).
    
    Для всех объектов будет работать пагинация, чтобы мы могли постранично выводить их на экран, а также можно будет посмотреть самые новые фильмы.
    


### Шаг 1. Создание моделей

- Жанры (создана)
- Режиссеры
- Фильмы
- Пользователи

### Шаг 2. Создание DAO, сервисов и эндпоинтов для фильмов, жанров и режиссеров

- **GET** /movies/
- **GET** /movies/{id}
- **GET** /genres/
- **GET** /genres/{id}
- **GET** /directors/
- **GET** /directors/{id}

Для тех эндпоинтов, которые возвращают несколько записей, нужно организовать пагинацию через URL-параметр page, а на страницу будет возвращать по 12 записей. Параметр page - необязательный, а значит, если он не указан - нужно вернуть все записи.

Так как мы хотим получать Новинки, для эндпонта GET /movies/ нужно еще добавить необязательный параметр status. Если он присутствует и имеет значение new — возвращаем записи в отсортированном виде (самые свежие), иначе возвращаем в том порядке, в котором они лежат в базе. Запрос может выглядеть так:

- */movies/?status=new&page=1*
- */movies/?page=2*
- */movies/*

### Шаг 3. Создание страниц авторизации



- **POST** /auth/register — передавая  email и пароль, создаем пользователя в системе.
- **POST** /auth/login — передаем email и пароль и, если пользователь прошел аутентификацию, возвращаем пользователю ответ в виде:
    
    ```json
    {
       "access_token": "qwesfsdfa",
       "refresh_token": "kjhgfgjakda",
    }
    ```
    

- **PUT** /auth/login — принимаем пару токенов и, если они валидны, создаем пару новых.


### Шаг 4. Работа с пользователем

- **GET** /user/ — получить информацию о пользователе (его профиль).
- **PATCH** /user/ — изменить информацию пользователя (имя, фамилия, любимый жанр).
- **PUT** /user/password — обновить пароль пользователя, для этого нужно отправить два пароля *old_password* и *new_password.*

Для того чтобы все ссылки корректно работали, их нужно обернуть в декоратор, в котором мы будет проверять переданный токен. 

## Задание со звездочкой

**Добавьте возможность добавлять фильмы в избранное** 

На прошлом шаге мы создавали пользователя, ему нужно добавить поле **favorite_genre** и сделать ссылку на модель с жанрами.

Для хранения понравившихся пользователем фильмов нам понадобится отдельная таблица, которая будет иметь связь «многие ко многим», ее структура:

- user_id
- movie_id

Таким образом, мы сможем однозначно понять, какие фильмы нравятся отдельному пользователю и, например, скольким пользователям понравился отдельный фильм.

Добавьте эндпоинты:

- **POST** /favorites/movies/{movie_id} — добавить фильм к пользователю в Избранное.
- **DELETE** /favorites/movies/{movie_id} — удалить фильм из Избранного.

**Добавьте тесты**

Напишите несколько тестов для DAO

Напишите несколько тестов для сервисов

Напишите несколько тестов на вьюхи

**Напишите документацию**

Напишите хорошую документацию для swager, согласно спецификации с сайта библиотеки [flask_restx](https://flask-restx.readthedocs.io).

